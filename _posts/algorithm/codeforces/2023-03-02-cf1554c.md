---
layout: post
title: "CF1554C: 按位构造"
cf: "1554-C"
date: 2023-03-02
tags: [算法, Codeforces, 位运算]
toc: true
comments: true
author: vveicc
---

> 输入 $t(≤3e4)$ 表示 $t$ 组数据，每组数据输入两个整数 $n$ 和 $m$，均在 $[0, 1e9]$ 范围内。<br>
> 定义数组 $a = [n \oplus 0, n \oplus 1, n \oplus 2, ..., n \oplus m]$。<br>输出不在 $a$ 中的最小非负整数。

{% include view_in_oj.html %}

<!-- more -->

---

根据题意，需要找到最小的 $x$ ，使得 $n \oplus x > m$ 。

显然，当 $n > m$ 时，答案为 0 。

## 方法一：从高到低按位构造

令 $k = m+1$ ，则 $x$ 需要满足 $n \oplus x ≥ k$。

分别使用 $n_i, k_i, x_i$ 表示 $n, k, x$ 的二进制第 $i$ 位。

从高位到低位按位构造，对于第 $i$ 位，有以下四种情况：

| $n_i$ | $k_i$ | 如何处理能够保证 $n \oplus x ≥ k$ 且 $x$ 最小？|
| :-: | :-: | :--- |
| 0 | 0 | 将 $x_i$ 赋为 0 |
| 1 | 1 | 将 $x_i$ 赋为 0 |
| 0 | 1 | 将 $x_i$ 赋为 1 ，如果赋为 0 将会导致 $n \oplus x < k$ |
| 1 | 0 | 将 $x_i$ 赋为 0 ，此时已经能保证 $n \oplus x ≥ k$，为了使 $x$ 最小，需要将剩余的二进制位全部赋为 0 |

代码实现：

```java Java
import java.io.*;
import java.util.*;

public class Main {

    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    public static void main(String[] args) throws Exception {
        int t = Integer.parseInt(in.readLine());
        for (; t > 0; t--) {
            StringTokenizer tokenizer = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tokenizer.nextToken());
            int k = Integer.parseInt(tokenizer.nextToken()) + 1;
            if (n >= k) {
                out.println(0);
            } else {
                int x = 0;
                int i = 1;
                for (; k >> i != 0; i++) {}
                for (; i >= 0; i--) {
                    int ni = (n >> i) & 1;
                    int ki = (k >> i) & 1;
                    if (ni == 0 && ki == 1) {
                        x |= 1 << i;
                    } else if (ni == 1 && ki == 0) {
                        break;
                    }
                }
                out.println(x);
            }
        }
        out.flush();
        out.close();
        in.close();
    }
}
```

```go Go
package main

import (
    "bufio"
    . "fmt"
    "os"
)

func main() {
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()

    var T, n, m int
    for Fscan(in, &T); T > 0; T-- {
        if Fscan(in, &n, &m); n > m {
            Fprintln(out, 0)
        } else {
            i, x := 1, 0
            for m++; m>>i != 0; i++ {
            }
            for ; i >= 0; i-- {
                if n>>i&1 == 0 && m>>i&1 == 1 {
                    x |= 1 << i
                } else if n>>i&1 == 1 && m>>i&1 == 0 {
                    break
                }
            }
            Fprintln(out, x)
        }
    }
}
```

## 方法二：基于 $n \oplus m$构造

令 $x = n \oplus m$ ，此时 $x$ 不满足 $n \oplus x > m$ ，考虑如何修改 $x$ 能够满足条件。

分别使用 $n_i, m_i, x_i$ 表示 $n, m, x$ 的二进制第 $i$ 位。

对于 $x$ 的每一个二进制位，有以下四种情况：

| $n_i$ | $m_i$ | $x_i$ | 如何修改 $x$ 能够增大 $n \oplus x$ 且保证 $x$ 最小？|
| :-: | :-: | :-: | :--- |
| 0 | 1 | 1 | 不能修改 $x_i$ ，将 $x_i$ 改为 0 会导致 $n \oplus x$ 减小 |
| 1 | 1 | 0 | 不能修改 $x_i$ ，将 $x_i$ 改为 1 会导致 $n \oplus x$ 减小 |
| 1 | 0 | 1 | 将 $x_i$ 改为 0 能够增大 $n \oplus x$ ，同时导致 $x$ 减小，为了使 $x$ 最小，需要修改该情况的最高位，并将其后低位全部置 0 |
| 0 | 0 | 0 | 将 $x_i$ 改为 1 能够增大 $n \oplus x$ ，同时导致 $x$ 增大，为了使 $x$ 最小，需要修改该情况的最低位，并将其后低位全部置 0 |

注意，第三种情况是最优的，但可能不存在这种情况，此时需要通过第四种情况修改 $x$ 。

代码实现：

```java Java
import java.io.*;
import java.util.*;

public class Main {

    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

    public static void main(String[] args) throws Exception {
        int t = Integer.parseInt(in.readLine());
        for (; t > 0; t--) {
            StringTokenizer tokenizer = new StringTokenizer(in.readLine());
            int n = Integer.parseInt(tokenizer.nextToken());
            int m = Integer.parseInt(tokenizer.nextToken());
            if (n > m) {
                out.println(0);
            } else {
                int i = 0;
                int x = n ^ m;
                if ((n & x) == 0) {
                    for (int y = n | x; (y >> i & 1) == 1; i++) {}
                    out.println((x >> i | 1) << i); // 通过第四种情况修改x
                } else {
                    for (int y = n & x; (y >> i) != 0; i++) {}
                    out.println(x >> i << i); // 通过第三种情况修改x
                }
            }
        }
        out.flush();
        out.close();
        in.close();
    }
}
```

```go Go
package main

import (
    "bufio"
    . "fmt"
    "os"
)

func main() {
    in := bufio.NewReader(os.Stdin)
    out := bufio.NewWriter(os.Stdout)
    defer out.Flush()

    var T, n, m int
    for Fscan(in, &T); T > 0; T-- {
        if Fscan(in, &n, &m); n > m {
            Fprintln(out, 0)
        } else {
            x := n ^ m
            if i := 0; n&x == 0 {
                for y := n | x; y>>i&1 == 1; i++ {
                }
                Fprintln(out, (x>>i|1)<<i) // 通过第四种情况修改x
            } else {
                for y := n & x; y>>i != 0; i++ {
                }
                Fprintln(out, x>>i<<i) // 通过第三种情况修改x
            }
        }
    }
}
```
